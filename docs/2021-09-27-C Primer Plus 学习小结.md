---

---

# C Primer Plus 学习小结

最近买了这本经典，想要复习一下C的内容，顺便看看C加入了新的标准后有何变化，看的过程中发现了一些有意思的事情。

## 关于C的可移植性的讨论

在我的认知里C程序的运行对环境的要求很高，比起 *Java* 的 *write once run anywhere*，C语言基本不存在可移植性一说，然而这是我的误解。

书中将汇编语言和C进行比较，因为机器硬件的不同，以汇编语言编写的程序要想转移到另外一台机器上运行，有极大的可能会重新编码，因为机器之间的汇编指令可能会不同。但是用C语言来编写就不成问题，高级语言通过**编译器**来编译成机器语言，将编译后的程序在机器上运行，能够期望得到一致的结果。显然，C语言的可移植性依赖于编译器的实现，在这里就发生了有趣的事情。

编译器的实现依赖于标准，像 *Java* 一样存在[语言标准](https://docs.oracle.com/javase/8/)。但是C存在一些暧昧的标准，这些标准并未规定编译器的行为，这样编译器很尴尬，这些行为代码中会出现，但是我们不知道要将这种行为导向什么样的后果，编译器只能自己琢磨出一些办法，这也导致了同样的代码在不同的编译器下的行为不一致。

是不是已经感觉到C标准的混乱了呢？但是我们研究的C语言并不是依赖于某个编译器实现下的情况，如果只讨论这个部分（不依赖编译器的部分），那我们可以说***C语言编写的程序是可移植的***。

影响C程序可移植性的不仅仅是编译器，操作系统也是一个方面。比如经常用来举例的*Socket*编程，其在*windows*和*Linux*上的实现是不一致的，其函数声明也是不一致的。如果我们编写的程序不依赖于操作系统的特定实现，那我们也可以说***C语言编写的程序是可移植的***。

## 关于宏

我对于宏的理解一直有问题，一直都是从形式上理解。比如 **#include** ，我之前的理解就是加入了文件的引用，和 **import** 差不多；比如 **#define**，我之前的理解是，相当于定义了一个变量；如果定义的是含参数的宏，那么我就当成是一个函数去理解。

上面的说法我认为完全是错误的，千万不要被我误导，以下是我现在认为正确的理解：

宏，理解成 **查找 / 替换 / 拷贝 / 粘贴** 的功能更好一些。比如 **#include  <stdio>** ，就是将 **stdio.h** 文件中的内容拷贝，然后粘贴到有标记这个宏的文件当中；比如 **#define Length 5**，其实是将代码中的 **Length** 替换成 **5**。含参数的宏，**#define MAX(a,b) a > b ? a : b**，在使用的时候我们会像下面这样：

```c
#define MAX(a,b) a > b ? a : b
int main()
{
    int num1 = 5, num2 = 6;
    MAX(num1,num2);
}
```

很容易理解成一个函数吧，num1和num2是实参，a和b是形参。其实不然，这里**MAX(num1,num2);**做的，其实是将文字a与b和文字num1与num2进行替换，然后把替换后的字符串放到**MAX**标记的位置：

```c
#define MAX(a,b) a > b ? a : b
int main()
{
    int num1 = 5, num2 = 6;
    MAX(num1,num2);//替换后为 num1 > num2 ? num1 : num2;
}
```

## 关于声明

我认为C语言最复杂的就是声明。声明可以帮助程序员来理解标识符的用途，C语言的声明属实是复杂，大家觉得指针难以理解可能也是因为声明的复杂性吧。

