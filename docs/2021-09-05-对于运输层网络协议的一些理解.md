---
layout: post
title: 对于运输层网络协议的一些理解
subtitle: 还一还计算机网络欠下的债
cover-img: /assets/img/raspberry-head.jpg
thumbnail-img: /assets/img/raspberry-cover.jpg
share-img: /assets/img/raspberry-cover.jpg
tags: [计算机网络]
comments: true
last-updated: 2021-09-04 15:42
---

# 对运输层网络协议的一些理解

这回我们来聊一聊运输层以及运输层协议 - **TCP / UDP**。

## 对运输层的理解 

首先简单介绍一下网络层。网络层是运输层之下的协议，其仅仅负责主机到主机之间的传输，而且非常的不负责任，既不保证报文段的顺序传输，也不保证报文段会妥善到达，它仅仅是一种**尽力而为的交付服务**。

于是运输层有了选择，我可以继续使用网络层的这种“特性”，或者我要在其上添加一些保障措施，但是无论如何，我运输层必须要实现的是进程与目的进程之间的通信，这可以说是运输层的根本职责。所以运输层有了**UDP** - 无连接的不可靠的服务；**TCP** - 面向连接的可靠的服务。（这里UDP和TCP的来源仅仅是我个人的猜想，并无材料佐证。）

网络层来保证主机和主机之间的通信，运输层来保证进程和进程之间的通信。主机之间可以通过IP地址作为唯一标识进行通信，那么进程之间呢？

在socket编程实验中，一个服务端应用总要绑定自己的地址以及一个端口号，并且如果端口号被占用则无法启动服务端程序。我们可以猜想，一个端口只能被一个进程所占用，那么就可以通过端口号来识别进程。运输层也确实是这么做的，在运输层报文段中含有**源端口号**和**目的端口号**两个字段，用于标明两个进程，这样报文段携带的数据就可以精确送达至进程中从而完成一次通信。

> 仔细回想socket编程实验中所建立的客户端应用。客户端并没有绑定自身的端口号，那服务端是如何向客户端进程发送消息的呢？这是因为在创建socket的时候，运输层会为客户端分配一个端口号，这个过程是自动的，当然你也可以手动为客户端绑定一个端口，只要这个端口没有被其它进程占用即可。
>
> 当服务端向客户端进程发送消息的时候，目的端口就是客户端分配的端口号，报文段到达客户端以后，运输层就会将报文段交给目的进程。

以上是运输层**多路复用**以及**多路分解**的内容。多路复用即是对端口号的封装（屏蔽），在报文段上加入头部完成封装并发往目的IP地址；多路分解即使对数据报的拆箱，去掉数据报的头部露出报文段得到端口号。经过多路复用和多路分解的过程即可完成进程到进程之间的访问。

## 对Socket套接字的理解

对于开发者而言，***socket***是一个很重要的概念。刚刚接触 ***socket*** 的时候非常直观，认为 ***socket*** 就是一个可以帮助我们建立运输层连接的工具。

我现在的理解是这样的：***socket*** 确实是一个工具，帮助我们完成网络通信的任务。它位于应用层与运输层之间，可以理解成是两层进行交互的接口。开发者活跃在应用层，在使用 ***socket*** 的时候，我们仅仅需要决定绑定哪个端口，使用哪个协议，发送或者接收什么数据这些事情，让我们将目光更聚焦于开发之中，而不需要在意底层是如何进行传输。

在我们的主机上有很多个这样的应用，或者说是进程。进程和建立的 ***socket*** 可能是一对多的，运输层在向应用层传输数据的时候也需要识别究竟要送往哪一个 ***socket*** ，这样，每一个 ***socket*** 需要有一个唯一的标识。

对于**UDP**和**TCP**的标识有不同的格式。**UDP**建立的***socket***标识是二元组的形式，**TCP**建立的***socket***标识是四元组的形式。

```c
(dst_ip, dst_prot) // UDP: 目的地址和目的端口
(src_ip, src_port, dst_ip, dst_port) // TCP: 源地址，源端口，目的地址，目的端口
```

有了唯一标识，运输层就能通过报文段当中的端口号来找到相应的***socket***并交付数据。

在socket实验当中，我们建立的服务端应用一次只能处理一条与客户端的连接，要处理并发的场景我们可以启用多线程来进行处理：当客户端进行连接时启用一个新的线程来处理这次连接。多线程只是其中的一种解决方法，我会寻找其它的方法之后再来进行总结。

## 对 UDP / TCP 的理解 







