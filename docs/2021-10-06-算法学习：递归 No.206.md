# 算法学习：递归 No.206

## [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

背景：链表

目的：反转链表

方法：递归

如果使得任意两个结点反向连接，假设这两个节点为 `first` 和 `next` ，应该有 `next -> next = first` ，但在这之前应该将 `next` 节点的下一个节点保存下来，否则将访问不到下一个节点。

处理完 `first` 和 `next` 节点之后，就应该处理 `next` 和已经保存的下一个节点，处理的过程和上面一样，这就形成了一个递归的过程。

递归的又一个重点是出口条件，按上文所说的递归方法，递归应该在链表末尾结束。4 和 5 两个节点反转结束后，`first` 节点将指向节点 5，而 `next` 节点会指向 `nullptr`，所以当 `next == nullptr` 时，退出递归。

最终要返回的是反转链表后的头节点，在退出递归时 `first` 正好指向反转前最后一个节点，返回该节点即可。

额外需要注意的是反转前的头节点，它的 `next` 需要指向 `nullptr`，不然链表会有环。

最终实现的函数如下：

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head == nullptr)
        {
            return head;
        }
        return reverseList(head,head->next);
    }
    ListNode* reverseList(ListNode* first,ListNode* next) {
        if(next == nullptr)
        {
            return first;
        }
        if(first->next == next)
        {
            first->next = nullptr; 
        }
        ListNode* save = next->next;
        next->next = first;
        return reverseList(next, save);
    }
};
```

可以更换一种递归方式。

上文当中的递归是从链表的首部开始遍历的，反转操作会使得某一时刻链表是中断的，无法通过 `next` 直接访问到未来的节点，于是需要在反转之前保存下一节点，那有没有办法让链表无法中断呢？

试想一下递归从尾部开始遍历，比如先反转 4 和 5 两个节点，再反转 3 和 4 两个节点，向下一个目的节点移动的过程可以交给递归自身来实现，并不需要我们主动去寻找下一个目的节点。

所以这个递归需要在反转之前完成。

那么递归的出口如何确定，何时结束我们的递归

