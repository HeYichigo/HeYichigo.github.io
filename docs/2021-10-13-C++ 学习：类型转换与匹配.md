

# C++ 学习：类型转换与匹配

这里讨论的类型为 C++ 语言中的基本类型。

在我们平时的使用中，很少主动去变换一个量的类型，在不知不觉中（尤其在使用函数的过程中）会出现很多错综复杂的 **隐式的** 类型转换，导致函数获得的结果并非在我们意料之中，我认为 C++ 中的一切麻烦皆来于此。

这篇文章会探讨 C++ 中，何时发生了转换以及发生了何种类型的转换。

我们的目的是了解这些 **隐式的** 转换，并且尽可能的使用 **类型安全** 的转换。

> 在表达式计算或者常量赋值时，我们很容易判断是否发生了类型安全的转换。

## 本文讨论的基本类型

| bool | char | short | int  | long | float | double |
| :--: | :--: | :---: | :--: | :--: | :---: | :----: |

| 引用：& | 指针：* | 数组：[] |
| :-----: | :-----: | :------: |

| signed | unsigned |
| :----: | :------: |

| const | volatile |
| :---: | :------: |

第一行是基本类型，按照所占字节大小（从1Byte开始）进行排列；第二行是可加在基本类型后面的，具有特殊意义的操作符；第三行和第四行是修饰符。行与行之间可以任意组合，可以涵盖大多数变量以及形参的定义。

## 何种类型的转换

### 整型提升(自动提升)

上表中，位于 `int` 左边的任意 `signed` `unsigned` 类型（`unsigned short` 除外）被自动转换为 `int` 。

`unsigned short` 可能会被转换为 `unsigned int` ，这取决于系统或编译器定义的 **类型宽度** ，当然这也被称为 **整型提升** 。

> 当然还有 `wchar_t` ，为了保证类型安全也会进行整型提升，将 `wchar_t` 转换为一个 `int` 之后的、类型安全的、最小宽度类型。可能仍然是 `int` ，也可能是 `unsigend int` 或者宽度更宽的类型。

这些转换是安全的，因为编译器的实现保证了 `int` 比这些类型能容纳更大的数据（宽度更宽），在进行整型提升时不会损失精度。

这个过程是自动的，即如果满足要求，编译器会自动执行整型提升，同时也是编译器首选的转换模式，如果这个模式不满足类型安全则编译器会使用其它策略。

### 整型转换

整形转换是指整型在 `signed` 以及 `unsigned` 之间的转换。

这个转换在进行表达式计算时是有规则的：

1. 两个操作数 **都** 是 `signed` 或 `unsigned` 的，则向优先级高的一侧转换。
2. 两个操作数一个是 `signed` 一个是 `unsigned` ，`unsigned` 的级别高于 `signed` ，则向 `unsigned` 一侧转换。
3. 若 `signed` 级别高于 `unsigned` ，且 `signed` 能够容纳 `unsigned` 所能表示的所有数字，则向 `signed` 一侧转换。
4. 否则 将两个类型转换为 有符号类型（默认有符号的类型）的无符号版本。

这个转换不总是安全的，因为两种形式可表示的数据范围不同。能发生这种情况的场景也十分有限，只会发生在 `signed` 和 `unsigned` 互相赋值的场景下（平时很少使用）。

### 浮点转换

指 `float` 和 `double` 相关类型的转换。

从宽度上看，只有 `float` 转换为 `double` 的行为是安全的。

> 如果非需要，不要做从 **浮点类型** 向 **整型** 的转换，这种转换通常有 **截断** 和 **溢出** 两种结果。
>
> **截断** 的结果经常被用于浮点数取整；**溢出** 很可能是我们小看了浮点类型能够表示的数的范围，而溢出的结果往往是我们所讨厌的。

### 用户定义的转换

在 `class` 中可以进行类型转换的定义，称为 **转换函数**：

```c++
operator typename() 
```

转换函数定义了将类转换为其它类型的行为。除非必要，否则不要使用转换函数。

## 何时发生类型转换

### 表达式计算时的转换

编译器遇到表达式计算时会按照下面的规则进行类型转换：

从最宽的 **浮点类型** `long double` 开始检查，如果存在 `long double` 则将其它操作数转换为 `long double` ;

进行 `double` 的检查；进行 `float` 的检查；进行 **整型提升** ；进行 **整形转换** ；

### 初始化和赋值时的转换

进行宽度提升的转换总是安全的，在进行初始化和赋值时通常也遵循该原则。

1. **以常量（字面量）进行的初始化**

   如果没有其它理由，编译器总会将 **数字** 作为 `int` 类型对待；如果有后缀（比如浮点类型的 **f** 、无符号长整形的 **ul**）则转换为后缀标识的类型；如果 `int` 的能够表示的范围不够大，则向更宽的整型转换。

2. **不允许缩窄的初始化**

   C++ 11 的新特性 **列表初始化** ，使用列表初始化进行初始化操作时，不允许将列表中的数据类型 **缩窄** 使用。

   ```c++
   char c1 {31325};  // narrowing, not allowed
   ```

   31325 超过了 `char` 能够表示的数据范围，如果不使用 **列表初始化** 则 `c1` 将进行溢出表示；如果使用了 **列表初始化** 则会出现编译错误。

我们在进行赋值时常常也会使用常量，有时也会用到表达式，这两种情况的规则已经在上文介绍过了，要注意的是：在表达式赋值时，转换或许不仅发生一次。

```c++
short res;
short a = 10;
short b = 20;
res = a + b;
```

在这个代码中，在定义 `a` `b` 时会出现 `int` 向 `short` 转换的情况；在进行 `res = a + b ` 时，`a + b` 会作为 `int` 进行计算，最终向 `res` 赋值时也会进行 `int` 向 `short` 转换的情况。

### `const` 相关的转换

只允许从 **non-const** 向 **const** 的转换。

### 函数调用时的转换

若实参与形参类型不一致，则编译器会将 **实参** 类型向 **形参** 转换。

若函数返回非 `void` 类型，在计算 `return` 表达式时也会进行转换。
