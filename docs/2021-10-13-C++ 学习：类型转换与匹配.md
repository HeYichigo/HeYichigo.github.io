

# C++ 学习：类型转换与匹配

这里讨论的类型为 C++ 语言中的基本类型。

在我们平时的使用中，很少主动去变换一个量的类型，在不知不觉中（尤其在使用函数的过程中）会出现很多错综复杂的 **隐式的** 类型转换，导致函数获得的结果并非在我们意料之中，我认为 C++ 中的一切麻烦皆来于此。

这篇文章会探讨 C++ 中，何时发生了转换以及发生了何种类型的转换。

我们的目的是了解这些转换，并且尽可能的使用 **类型安全** 的转换。

## 本文讨论的基本类型

| bool | char | short | int  | long | float | double |
| :--: | :--: | :---: | :--: | :--: | :---: | :----: |

| 引用：& | 指针：* | 数组：[] |
| :-----: | :-----: | :------: |

| signed | unsigned |
| :----: | :------: |

| const | volatile |
| :---: | :------: |

第一行是基本类型，按照所占字节大小（从1Byte开始）进行排列；第二行是可加在基本类型后面的，具有特殊意义的操作符；第三行和第四行是修饰符。行与行之间可以任意组合，可以涵盖大多数变量以及形参的定义。

## 何种类型的转换

### 整型提升

上表中，位于 `int` 左边的任意 `signed` `unsigned` 类型（`unsigned short` 除外）被自动转换为 `int` 。

`unsigned short` 可能会被转换为 `unsigned int` ，这取决于系统或编译器定义的 **类型宽度** ，当然这也被称为 **整型提升** 。

> 当然还有 `wchar_t` ，为了保证类型安全也会进行整型提升，将 `wchar_t` 转换为一个 `int` 之后的、类型安全的、最小宽度类型。可能仍然是 `int` ，也可能是 `unsigend int` 或者宽度更宽的类型。

这些转换是安全的，因为编译器的实现保证了 `int` 比这些类型能容纳更大的数据（宽度更宽），在进行整型提升时不会损失精度。

