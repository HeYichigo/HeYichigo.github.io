---
layout: post
title: 算法学习：每日一题 No.434
subtitle: 434. 字符串中的单词数
tags: [算法,字符串]
comments: true
last-updated: 2021-10-07 10:16
---

# 算法学习：每日一题 No.434

## [434. 字符串中的单词数](https://leetcode-cn.com/problems/number-of-segments-in-a-string/)

背景：字符串

目的：统计单词数

方法：字符串遍历（硬起名字）

```c++
string s = "Hello, my name is John"
```

在这个命题当中，指出了单词是连续的不是空格的字符，也就是说 `Hello,` 算作一个单词。

我们的目的也就明确了：找出空格后的第一个字符，就相当于找到了一个字符串。即该位置本身不是空格，该位置的前一位是空格。

也存在特殊的情况，比如字符串的开始就是一个单词，然而只用上面的方法会丢掉这个单词。

所以对于字符串的开始要特殊处理：字符串开始如果不是空格，那么就算是一个单词，不需要看前一位是不是空格。

这里就需要用到 **逻辑运算符** 短路的性质。

我们希望字符串开始时不进行前一位的判断：

```c++
if(i == 0 || s.at(i - 1) == ' '){}
```

`||` 可以帮助到我们，当 ` i == 0 ` 时表明是字符串的开始，运算符左侧为真，就不再进行右侧的运算，也就达到了我们的目的。

字符串起始之外的判断方式：

```c++
if(s.at(i - 1) == ' ' && s.at(i) != ' '){}
```

如果两段逻辑直接组合的话会出现越界的情况，即当 `i = 0` 时， `i - 1` 发生越界，我们需要避免这种状况。

```c++
if ((i==0 || s.at(i - 1) == ' ' ) && s.at(i) != ' ')
```

这样组合就可以达到我们的目的，最终完整的程序如下：

```c++
class Solution {
public:
    int countSegments(string s) {
        int count = 0;
        for (int i = 0; i < s.size(); ++i)
        {
            if ((i==0 || s.at(i - 1) == ' ' ) && s.at(i) != ' ')
            {
                ++count;
            }
        }
        return count;
    }
};
```

## 总结

逻辑运算短路的性质会经常出现。